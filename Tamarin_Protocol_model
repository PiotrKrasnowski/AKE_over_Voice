theory AKE_over_voice_channels
begin

builtins: diffie-hellman, signing, hashing

// Generation of the key pair

rule Generate_pk:
  [ Fr(~ltk) ] 
  --[ Generate($U) ]->
  [ !Ltk( $U, ~ltk ), !Pk( $U, pk(~ltk) ) ]

// Adversary reveals the secret key

rule Reveal_ltk:
    [ !Ltk( A, ltk ) ]
  --[ LtkReveal( A ) ]->
    [ Out(ltk) ]

// Authenticated channel

rule VoiceChannelOut_Authenticated:
    [ Out_A( $I, $R, x ) ]  --[ ChanOut_A( $I, $R, x ) ]->  [ !Auth( $I, x ), Out(< $I, $R, x >) ]

rule VoiceChannelIn_Authenticated:
    [ !Auth( $I, x ), In($R) ] --[ ChanIn_A( $I, $R, x ) ]-> [ In_A( $I, $R, x ) ]

// Protocol rules

rule Init_1:
    [ Fr(~ekI)
    , Fr(~NI)
    , In( h(< $R, NR, Y >) ) ]
    -->
    [ Init_1( $I, ~NI, ~ekI, h(< $R, NR, Y >) )
    , Out(< $I, ~NI, 'g' ^ ~ekI >) ]

rule Init_2:
    [ Init_1( $I, ~NI, ~ekI, h(< $R, NR, Y >) )
    , !Ltk( $I, ltkI )
    , !Pk( $R, pk(ltkR) )
    , In(< $R, NR, Y, sign{'Resp', $R, $I, NR, ~NI, Y, 'g' ^ ~ekI }ltkR >) 
    ]
  --[ SessionKey( $I, $R, < $I, $R, ~NI, NR, Y ^ ~ekI >)
    , Running( 'R', $R, $I, < $I, $R, ~NI, NR, Y ^ ~ekI >)
    , Commit_S( 'I', $I, $R, < $I, $R, ~NI, NR, Y ^ ~ekI >) ]->
    [ Out( sign{ 'Init', $I, $R, ~NI, NR, 'g' ^ ~ekI, Y }ltkI )
    , Out_A( $I, $R, h(< $I, $R, ~NI, NR, Y ^ ~ekI >) ) ]

rule Init_2_nosign:
    [ Init_1( $I, ~NI, ~ekI, h(< $R, NR, Y >) )
    , !Ltk( $I, ltkI )
    , In(< $R, NR, Y, S >) 
    ]
  --[ SessionKey( $I, $R, < $I, $R, ~NI, NR, Y ^ ~ekI >)
    , Running( 'R', $R, $I, < $I, $R, ~NI, NR, Y ^ ~ekI >)
    , Commit( 'I', $I, $R, <$I, $R, ~NI, NR, Y ^ ~ekI >) ]->
    [ Out( sign{ 'Init', $I, $R, ~NI, NR, 'g' ^ ~ekI, Y }ltkI )
    , Out_A( $I, $R, h(< $I, $R, ~NI, NR, Y ^ ~ekI >) ) ]

rule Resp_0:
    [ Fr(~ekR)
    , Fr(~NR)
    ]
  --[]->
    [
      Resp_0( $R, ~NR, ~ekR)
    , Out( h(< $R, ~NR,'g' ^ ~ekR >) )
    ]

rule Resp_1:
    [ !Ltk( $R, ltkR )
    , Resp_0( $R, ~NR, ~ekR )
    , In(< $I, NI, X >) 
    ]
  --[ Running( 'I', $I, $R, <$I, $R, NI, ~NR, X ^ ~ekR >) ]->
    [
      Resp_1( $R, $I, ~NR, NI, X ^ ~ekR)
    , Out(< $R, ~NR, 'g' ^ ~ekR, sign{ 'Resp', $R, $I, ~NR, NI, 'g' ^ ~ekR, X }ltkR >)
    ]

rule Resp_2:
    [ 
      Resp_1( $R, $I, ~NR, NI, X ^ ~ekR )
    , !Pk( $I, pk(ltkI) )
    , In( sign{ 'Init', $I, $R, NI, ~NR, X, 'g' ^ ~ekR }ltkI ) 
    ]
  --[ SessionKey( $R, $I, < $I, $R, NI, ~NR, X ^ ~ekR >) 
    , Commit_S( 'R', $R, $I, < $I, $R, NI, ~NR, X ^ ~ekR >) ]->
    [
      Out_A( $R, $I, h(< $I, $R, NI, ~NR, X ^ ~ekR >) )  
    ]

rule Resp_2_nosign:
    [ Resp_1( $R, $I, ~NR, NI, X ^ ~ekR )
    , In(S) 
    ]
  --[ SessionKey( $R, $I, < $I, $R, NI, ~NR, X ^ ~ekR >)
    , Commit( 'R', $R, $I, < $I, $R, NI, ~NR, X ^ ~ekR >) ]->
    [
     Out_A( $R, $I, h(< $I, $R, NI, ~NR, X ^ ~ekR >) )  
    ]

rule Compare_validation_number:
    [ 
      In_A( $I, $R, sequenceI ), In_A( $R, $I, sequenceR )
    ]
    --[ CompareVC( 'I', $I, $R, sequenceI, sequenceR )
      , CompareVC( 'R', $R, $I, sequenceR, sequenceI ) ]-> []    

// lemmas

lemma executable :
exists-trace
  "Ex role I R sessKey #i.
    CompareVC( role, I, R, h(sessKey), h(sessKey) ) @ i &
    not( I = R ) &
    not( Ex U #k . LtkReveal(U) @ k )
  "

// authentication lemmas

lemma Non_Injective_Agreement :
  " //signed
   (
    All role U1 U2 sessKey #i.
      // user U1 playing a role 'role' completed a run presumably with U2 
      Commit_S( role, U1, U2, sessKey ) @ i
      // then U2 was running the protocol with U1
      // and both agreed on sessKey
      ==> ( Ex #j. Running( role, U1, U2, sessKey ) @ j )
        // or the adversary revealed a secret key of the user U2
        | ( Ex #r. LtkReveal(U2) @ r & r < i )
   ) 
   & // unsigned & VC compared
   (
    All role U1 U2 sessKey #i #j.
      // user U1 playing a role 'role' completed a run presumably with U2
      Commit( role, U1, U2, sessKey ) @ i &
      CompareVC( role, U1, U2,  h(sessKey), h(sessKey) ) @ j & not( U1 = U2 )
      // then U2 was running the protocol with U1
      // and both agreed on sessKey
      ==> ( Ex #k. Running( role, U1, U2, sessKey) @ k)
        // or the adversary revealed a secret key of the user U2
        | ( Ex #r. LtkReveal(U2) @ r & r < i )
   )"

lemma Non_Injective_Agreement_no_sign_nor_VC :
  exists-trace
  "
  not All role U1 U2 sessKey #i.
      // user U1 playing a role 'role' completed a run presumably with U2 
      Commit( role, U1, U2, sessKey ) @ i
      // but U2 was NOT running the protocol with U1
      ==> ( Ex #k. Running( role, U1, U2, sessKey ) @ k )
        // or the adversary revealed a secret key of the user U2
        | ( Ex #r. LtkReveal(U2) @ r & r < i )
  "

lemma Injective_Agreement :
  " //signed
   (
    All role U1 U2 sessKey #i.
    // user U1 playing a role 'role' completed a run presumably with U2 
    Commit_S( role, U1, U2, sessKey ) @ i
    // then U2 was running the protocol with U1
    // and both agreed on sessKey
    ==> (Ex #j. Running( role, U1, U2, sessKey ) @ j & j < i
      // and there is a unique matching instance
      & not ( Ex U3 U4 #i2. Commit_S( role, U3, U4, sessKey ) @i2 & not ( #i2 = #i ) )
      & not ( Ex U3 U4 #i2. Commit( role, U3, U4, sessKey ) @i2 & not ( #i2 = #i ) ) )
      // or the adversary revealed a secret key of the user U2
      | ( Ex #r. LtkReveal(U2) @ r & r < i )
   )
   & // unsigned & VC compared
   (
    All role U1 U2 sessKey #i #j.
    // user U1 playing a role 'role' completed a run presumably with U2 
    Commit( role, U1, U2, sessKey ) @ i & not( U1 = U2 ) &
    CompareVC( role, U1, U2, h(sessKey), h(sessKey) ) @ j
    // then U2 was running the protocol with U1
    // and both agreed on sessKey
    ==> ( Ex #k. Running( role, U1, U2, sessKey ) @ k & k < j
      // and there is a unique matching instance
      & not ( Ex U3 U4 #i2. Commit_S( role, U3, U4, sessKey ) @ i2 & not ( #i2 = #i ) )
      & not ( Ex U3 U4 #i2. Commit( role, U3, U4, sessKey ) @ i2 & not ( #i2 = #i ) ) )
      // or the adversary revealed a secret key of the user U2
      | ( Ex #r. LtkReveal(U2) @ r & r < i )
    )"

lemma Injective_Agreement_no_sign_nor_VC :
  exists-trace
  "
  not All role U1 U2 sessKey #i.
    // user U1 playing a role 'role' completed a run presumably with U2
    Commit( role, U1, U2, sessKey ) @ i & not( U1 = U2 )
    // but U2 was NOT running the protocol with U1
    // or there is another matching instance
    ==> (Ex #k. Running( role, U1, U2, sessKey ) @ k & k < i
      & not (Ex U3 U4 #i2. Commit_S( role, U3, U4, sessKey ) @ i2 & not (#i2 = #i ) )
      & not (Ex U3 U4 #i2. Commit( role, U3, U4, sessKey )  @ i2 & not (#i2 = #i ) ) )
      // or the adversary revealed a secret key of the user U2
      | ( Ex #r. LtkReveal(U2) @ r & r < i )
  "

// secrecy lemmas

lemma Session_Key_Secrecy :
  " //signed
  (
  All role U1 U2 sessKey #i #l. 
     // user U1 playing a role 'role' completed a run presumably with U2 
     SessionKey( U1, U2, sessKey ) @ i &
     Commit_S( role, U1, U2, sessKey ) @ i & 
     // but the adversary knows the key anyway
     K(sessKey) @ l
     // then the adversary revealed a secret key of the user U2
     ==>
     Ex #r. LtkReveal(U2) @ r
  )
  & // unsigned & VC compared
  (
  All role U1 U2 sessKey #i #k #l.
     // user U1 playing a role 'role' completed a run presumably with U2 
     SessionKey( U1, U2, sessKey ) @ i &
     CompareVC( role, U1, U2, h(sessKey), h(sessKey) ) @ k & not( U1 = U2 ) &
     // but the adversary knows the key anyway
     K(sessKey) @ l
     // then the adversary revealed a secret key of the user U2
     ==>
     Ex #r. LtkReveal(U2) @ r
  )
  "

lemma Session_Key_Secrecy_no_sign_nor_VC :
  exists-trace
  "
  not All U1 U2 sessKey #i #j. 
     // user U1 playing a role 'role' completed a run presumably with U2
     SessionKey( U1, U2, sessKey ) @ i &
     // but the adversary knows the key anyway
     K(sessKey) @ j
     ==>
     // then the adversary revealed a secret key of the user U2
     Ex #r. LtkReveal(U2) @ r
  "

lemma Perfect_Forward_Secrecy :
  " //signed
  (
  All role U1 U2 sessKey keying #i #l.
     // user U1 playing a role 'role' completed a run presumably with U2 
     SessionKey( U1, U2, sessKey ) @ i &
     Commit_S( role, U1, U2, keying ) @ i & 
     // but the adversary knows the key anyway
     K(sessKey) @ l
     ==>
     // then the adversary revealed a secret key of the user U2 earlier
     Ex #r. LtkReveal(U2) @ r & r < i
  )
  & // unsigned & VC compared
  (
  All role U1 U2 sessKey #i #k #l.
     // user U1 playing a role 'role' completed a run presumably with U2
     SessionKey( U1, U2, sessKey ) @ i &
     CompareVC( role, U1, U2, h(sessKey), h(sessKey) ) @ k & not( U1 = U2 ) &
     // but the adversary knows the key anyway
     K(sessKey) @ l
     ==>
     // then the adversary revealed a secret key of the user U2 earlier
     Ex #r. LtkReveal(U2) @ r & r < i
  )
  "

// other lemmas

lemma Impersonation_with_signature :
  "
    All role U1 U2 sessKey #i.
    // user U1 playing a role 'role' completed a run presumably with U2
    Commit_S( role, U1, U2, sessKey ) @ i & not( U1 = U2 ) &
    // but U2 was NOT running the protocol with U1 (adversary impersonated U2)
    not( Ex #j. Running( role, U1, U2, sessKey ) @ j & j < i )
    // then the adversary revealed a secret key of the user U2 earlier
    ==> 
    Ex #r. LtkReveal(U2) @ r & r < i 
  "

lemma Reflection_with_signature :
  "
    All role U1 U2 sessKey #i.
    // user U1 playing a role 'role' completed a run presumably with U2
    Commit_S( role, U1, U2, sessKey ) @ i &
    // and was not running the protocol as both roles at the same time
    // (this configuration is not possible in the analyzed case)
    // (moreover, U1 would be aware of the double role)
    not( Ex role2 #j. Running( role2, U1, U2, sessKey ) @ j & not( role = role2 ) ) 
    ==> 
    // then U1 is different than U2
    not( U1 = U2 ) 
  "

lemma Reflection_no_signature :
  exists-trace
  "
  not All role U1 U2 sessKey #i .
    // user U1 playing a role 'role' completed a run presumably with U2
    CompareVC( role, U1, U2, h(sessKey), h(sessKey) ) @ i &
    // and was not running the protocol as both roles at the same time
    // (this configuration is not possible in the analyzed case)
    // (moreover, U1 would be aware of the double role)
    not( Ex role2 #j. Running( role2, U1, U2, sessKey ) @ j & not( role = role2 ) ) 
    ==>
    // but U1 is U2
    not( U1 = U2 ) 
  "

end
